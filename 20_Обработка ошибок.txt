ОБРАБОТКА ОШИБОК

Синтаксис:
    try {
        //код ...
    } catch (err) {
        //обработка ошибки
    }

Алгоритм:
    - выполняется код внутри try
    - если в нем нет ошибок, то блок catch игнорируется
    - если в try возникает ошибка, то его выполнение прерывается
        и управление передается catch(err)
        err - объект, содержащий подробную информацию об ошибке

Пример.
    try {

        alert('Начало блока try');  // (1) <--
        lalala; // ошибка, переменная не определена!
        alert('Конец блока try (никогда не выполнится)');

    } catch(err) {

        alert(`Возникла ошибка!`); // (3) <--

    }

Объект Error
    Свойства:
        - .name содержит имя ошибки
        - .message содержит текстовое сообщение о деталях ошибки
        - .stack содержит текущий стэк вызовов (строка)

ГЕНЕРАЦИЯ СОБСТВЕННЫХ ОШИБОК

Синтаксис:
    throw <объект ошибки>

    генерирует ошибку

Конструкторы ошибок:
    - Error(message)
    - SyntaxError(message)
    - ReferenceError(message)
    - TypeError(message)
    - др.


ПРОБРОС ИСКЛЮЧЕНИЯ
    Алгоритм:
        - блок catch получает все ошибки
        - в блоке catch мы анализируем объект ошибки err
        - если мы не знаем как обработать ошибку, генерируем новую - throw err

    Пример:
        let json = '{ "age": 30 }'; // данные неполны
        try {

            let user = JSON.parse(json);

            if (!user.name) {
                throw new SyntaxError("Данные неполны: нет имени");
            }

            blabla(); // неожиданная ошибка

            alert( user.name );

        } catch(e) {

            if (e.name == "SyntaxError") {
                alert( "JSON Error: " + e.message );
            } else {
                throw e; // проброс (*)
            }

        }

РАСШИРЕННЫЙ СИНТАКСИС
    try {
        ... пробуем выполнить код...
    } catch(e) {
        ... обрабатываем ошибки ...
    } finally {
        ... выполняем всегда ...
    }

    Секцию finally часто используют,
     когда мы начали что-то делать и хотим завершить это вне зависимости от того, 
     будет ошибка или нет.

    Например, мы хотим измерить время, которое занимает функция чисел Фибоначчи fib(n).
    Естественно, мы можем начать измерения до того, как функция начнёт выполняться и закончить после. 
    Но что делать, если при вызове функции возникла ошибка? 
    В частности, реализация fib(n) в коде ниже возвращает ошибку для отрицательных и для нецелых чисел.

    Секция finally отлично подходит для завершения измерений несмотря ни на что.

    let num = +prompt("Введите положительное целое число?", 35)

    let diff, result;

    function fib(n) {
        if (n < 0 || Math.trunc(n) != n) {
            throw new Error("Должно быть целое неотрицательное число");
        }
        return n <= 1 ? n : fib(n - 1) + fib(n - 2);
    }

    let start = Date.now();

    try {
        result = fib(num);
    } catch (e) {
        result = 0;
    } finally {
        diff = Date.now() - start;
    }

    alert(result || "возникла ошибка");

    alert( `Выполнение заняло ${diff}ms` );