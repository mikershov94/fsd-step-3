МАССИВЫ

1. Добавление/удаление элементов

    - .push() добавляет элемент в конец

    - .pop() удаляет последний элемент

    - .shift() удаляет первый элемент со сдвигом очереди

    - .unshift() добавляет элемент в начало массива

    shift и unshift работают медленно
    push и pop работают быстро


    - .splice(index[, deleteCount, elem1, ..., elemN])
        универсальный швейцарский нож для работы с массивами.
            -- удаляет элемент с позиции индекс
            -- удаляет количество элементов deleteCount начиная с index
            -- удаляет количество элементов deleteCount начиная с index
                и вставляет на это место элементы elem1, ..., elemN
            -- вставляет elem1, ..., elemN, начиная с index
                если deleteCount = 0
            --возвращает измененный массив

    - .slice([start], [end])
        создает копию массива и возвращает ее
            -- полную копию
            -- копия c позиции start по end

    - .concat(arg1, arg2, ...)
        он создает копию массива в которую добавляет другие массивы
            переданные в аргументах
            и возвращает ее

        В случае если методу concat передать объект-немассив, он будет вести себя некорректно.
        Поэтому необходимо передавать массивы.
        Или создавать объекты, которые ведут себя как массивы.
        Для этого
            - необходимо задать свойству [Symbol.isConcatSpreadable]: true
            - задать свойство .length


2. Перебор элементов

    - используем цикл for () {}
    
    - лучше подходит специальный цикл
        
        for (el of arr) {
            //код выполняется для каждого элемента массива
        }

    - есть еще цикл forEach

        arr.forEach(function(item, index, array) {
            //выполняется для каждого item с индексом index в массиве array
        })

3. Длина массива

    - свойство .length хранит длину объекта

    Это свойство динамически обновляется

4. Строчное представление массива

    Метод .toString(arr) возвращает строку с элементами массива, разделенных запятыми

    Массивы не имеют реализации Symbol.toPrimitive() или .valueOf()
    Они реализуют только toString().

5. Поиск в массиве

    Эти методы работают также как их строковые аналоги.
    Но работают с элементами.

    - .indexOf(item, from)      //ищет элемент item начиная с индекса from
                                    возвращает индекс элемента или -1
    - .lastIndexOf(item, from)  //также но работает с конца массива
                                    возвращает индекс элемента или -1
    - .includes(item, from)     //ищет элемент item начиная с индекса from
                                    возвращает true или false

    Специфичные для массивов методы

    - .find() для каждого элемента массива выполняет функцию с условием
        Если элемент найден, возвращает его. Иначе - undefined

            let result = arr.find(function(item, index, array) {
                //условие поиска
            })

            let user = users.find(item => item.id == 1);

    - .findIndex() для каждого элемента массива выполняет функцию с условием.
        Если элемент найден, возвращает индекс этого элемента. Иначе возвращает -1

    
    - .filter() для каждого элемента массива выполняет функцию с условием.
        Если элемент подходит к условию, добавляется в новый массив.
        По окончании перебора массив отобранных элементов возвращается.
        Иначе - undefined

            let result = arr.filter(function(item, index, array) {
                //условие фильтрации
            })

6. Преобразование массива

    - .map(function(item, index, array) { ... })
        метод выполняет для каждого элемента функцию.
        возвращает массив результатов выполнения этой функции

    - .sort(fn) сортирует массив и возвращает осортированный массив.
        Как правило возвращаемое значение игнорируется. Функция изменяет оригинал.

            -- по-умолчанию элементы сортируются как строки

            -- для иной сортировки в качестве аргумента нужно предоставить
                сортировочную функцию

                    Есть условие. Функция должна для пары значений возвращать:

                        function compare(a, b) {
                            if (a > b) return 1; // если первое значение больше второго
                            if (a == b) return 0; // если равны
                            if (a < b) return -1; // если первое значение меньше второго
                        }

            Рекомендация! Лучше использовать стрелочные функции

    - .reverse() меняет порядок элементов на обратный. Изменяет оригинал.

    - .split(delim) разбивает строку на массив элементов, отбрасывая разделитель delim

    - .join(delim) объединяет элементы массива в строку, добавляя разделитель delim


    - .reduce(function(previousValue, item, index, array) {})
        Функция переданная методу reduce выполняется для каждого элемента
            и переносит свой результат на каждый следующий вызов

        -- previousValue - результат предыдущего вызова функции
        -- item - элемент
        -- index - индекс элемента
        -- array - сам массив

    - .reduceRight() работает как reduce, но проходит по массиву справа налево

7. Проверка типа

    Массив это объект.
    Поэтому при проверке typeof будет возвращаться object

    Поэтому необходимо использовать специальную функцию

    Array.isArray(arg) - возвращает true, если переданный аргумент является массивом.
                            Иначе false

8. Передача контекста

    Почти все методы массивов, кроме sort(), принимают неявный аргумент thisArg

        - find(fn, thisArg)
        - filter(fn, thisArg)
        - map(fn, thisArg)

        Для fn значение параметра thisArg становится this.
        Туда передается контекст выполнения функции

    
    Пример.
        let army = {
            minAge: 18,
            maxAge: 27,
            canJoin(user) {
                return user.age >= this.minAge && user.age < this.maxAge;
            }
        };

        let users = [
            {age: 16},
            {age: 20},
            {age: 23},
            {age: 30}
        ];

        // найти пользователей, для которых army.canJoin возвращает true
        let soldiers = users.filter(army.canJoin, army);

        alert(soldiers.length); // 2
        alert(soldiers[0].age); // 20
        alert(soldiers[1].age); // 23

        Если бы мы не передали второй аргумент, то при выполнении метода canJoin
            this был бы равен undefined

