ФУНКЦИИ

1. Рекурсивное выполнение.

    Рекурсия - функция вызывает саму себя.

    Когда мы имеем дело с вложенными списками, вложенными HTML-тегами, вложенными объектами одного
        и того же типа, лучше использовать рекурсивный обход.

    Есть 2 варианта обработки:
        - итеративный обход
        - рекурсивный обход (лучше использовать его)

2. Неопределенное количество аргументов.

    В функцию могут быть передано любое количество параметров.
    Даже если описано всего 2 это не вызовет ошибку

        let sum = function(a, b) {
            return a + b;
        }

        let s = sum(1, 2, 3, 4)     //учтуться только 1 два

    - Оператор ...

        Можно использовать, чтобы собрать все аргументы в массив.

            let sum = function(...args) {
                let sum = 0;

                for (let arg of args) sum += arg;

                return sum;
            }
        
    - Псевдомассив arguments

        Когда функции передаются параметры, они попадают в псевдомассив
        Аргументы хранятся под своими порядковыми номерами.


            let sum = function() {
                
                console.log(arguments[0])
                console.log(arguments[1])

            }
    - Оператор расширения

        let arr = [1, 2, 3];

        let max = Math.max(...arr)

        ... перед массивом - оператор расширения.

        Оператор расширения разбивает массив в итерируемый список элементов.

        [...arr] - обратная операция расшрения

3. Замыкание

    Каждая функция, блок, скрипт имеют скрытый объект - LexicalEnvironment
    Лексическое окружение состоит:
    - EnvironmentRecord (объект, свойствами которого являются локальные переменные и this и др.)
        -- функции появляются перед начало выполнения кода
            то есть интерпретатор ищет ключевые слова function в коде
            добавляет функции в EnvironmentRecord
            после начинает выполнение основного код
    - Ссылка на внешний LexicalEnvironment

    Когда код хочет получить доступ к переменной, то сначала
        производится поиск во внутреннем лексическом окружении
        затем производится поиск во внешнем лексическом окружении
        и так далее до глобального

    Новое лексическое окружение создается при КАЖДОМ вызове функции.

    [[Environment]]
        Скрытое свойство, которое создается при рождении функции
        Ссылается на лексическое окружение, в котором она была создана
        Функция НАВСЕГДА запоминает окружение, в котором была создана

    Замыкание – это функция, которая запоминает свои внешние переменные
                 и может получить к ним доступ.
        Такая концепция достигается благодаря [[Environment]]
        Внешнее лексическое окружение функции хранится в памяти до тех пор,
         пока функция имеет ссылки на него.
        
        !!!В JavaScript все функции являются замыканиями!!!

    - If
        имеет свое собственное лексическое окружение
    - For, while
        каждая итерация имеет свое лексическое окружение
    - { ... }
        блок кода можно изолировать в фигурные скобки
        тогда код будет заточен в локальной области видимости
        его лексическое окружениие станет недоступным
    - IIFE-функция запускаемая сразу после объявления
        (function() {
            //выполнение кода
        })()

        имеет свое лексическое окружение также как Function Expression

    Устаревшая var не имеет блочной области видимости.
    Она игнорирует окружение вышеперечисленных блоков
        и становится глобальной
    Замыкание можно создать только функцией

